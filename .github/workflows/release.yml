name: Release (Velopack -> R2)

on:
  push:
    tags:
      - "v*"
      - "V*"

permissions:
  contents: write   # necesario para crear/editar GitHub Releases

jobs:
  build-pack-upload:
    runs-on: windows-latest

    env:
      # ---- Paths & metadata ----
      R2_PREFIX: ${{ vars.BASE_PREFIX }}           # ej: fs  (acabará en s3://<bucket>/<prefix>/)
      SLN_PATH: .\NuvAI FS.sln
      CSPROJ_PATH: .\NuvAI FS.csproj
      PUBLISH_DIR: .\publish
      ICON_PATH: .\app.ico
      MAIN_EXE: NuvAI FS.exe
      PACK_ID: NuvAI_FS
      PACK_TITLE: NuvAI FS
      PACK_AUTHORS: NuvAI LLC
      VPK_OUT: .\vpk_out

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Set VERSION from tag (strip leading 'v'/'V')
        shell: pwsh
        run: |
          $tag = "${{ github.ref_name }}"
          if ($tag.StartsWith("v",[System.StringComparison]::OrdinalIgnoreCase)) { $tag = $tag.Substring(1) }
          if ([string]::IsNullOrWhiteSpace($tag)) { Write-Error "VERSION vacío"; exit 1 }
          "VERSION=$tag" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          Write-Host "VERSION=$tag"

      - name: Setup .NET 8.x
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: "8.0.x"

      - name: Install Velopack CLI
        shell: pwsh
        run: |
          dotnet tool install -g vpk
          "$env:USERPROFILE\.dotnet\tools" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
          dotnet tool list -g
          vpk --help

      # (Opcional) Inyectar versión del tag en AssemblyInfo.cs si gestionas versión ahí
      - name: Inject version into AssemblyInfo.cs
        shell: pwsh
        run: |
          $ver = "$env:VERSION"
          $asm = if (Test-Path ".\Properties\AssemblyInfo.cs") { ".\Properties\AssemblyInfo.cs" } else { ".\AssemblyInfo.cs" }
          $ver3 = ($ver -replace '^([0-9]+\.[0-9]+\.[0-9]+).*$','$1')
          $ver4 = "$ver3.0"
          (Get-Content $asm) `
            -replace '^\s*\[assembly:\s*AssemblyVersion\(".*?"\)\]\s*$', "[assembly: AssemblyVersion(`"$ver4`")]" `
            -replace '^\s*\[assembly:\s*AssemblyFileVersion\(".*?"\)\]\s*$', "[assembly: AssemblyFileVersion(`"$ver4`")]" `
            -replace '^\s*\[assembly:\s*AssemblyInformationalVersion\(".*?"\)\]\s*$', "[assembly: AssemblyInformationalVersion(`"$ver`")]" `
            | Set-Content $asm -Encoding UTF8

      - name: Restore & Publish (Release, self-contained, win-x64)
        shell: pwsh
        run: |
          dotnet restore "$env:SLN_PATH"
          dotnet publish "$env:CSPROJ_PATH" -c Release -r win-x64 -p:SelfContained=true -o "$env:PUBLISH_DIR"

      - name: Velopack pack (usa VERSION del tag)
        shell: pwsh
        run: >
          if (Test-Path "$env:VPK_OUT") { Remove-Item "$env:VPK_OUT" -Recurse -Force };
          New-Item "$env:VPK_OUT" -ItemType Directory | Out-Null;
          vpk pack
          --packId "$env:PACK_ID"
          --packVersion "$env:VERSION"
          --packDir "$env:PUBLISH_DIR"
          --mainExe "$env:MAIN_EXE"
          --packAuthors "$env:PACK_AUTHORS"
          --packTitle "$env:PACK_TITLE"
          --noPortable
          --icon "$env:ICON_PATH"
          --shortcuts Desktop,StartMenuRoot,StartMenu
          --outputDir "$env:VPK_OUT";
          Write-Host "Contenido vpk_out:";
          Get-ChildItem "$env:VPK_OUT" -Recurse

      # --- NUEVO: mover TODOS los artefactos a carpeta versionada y generar latest.json ---
      - name: Prepare versioned folder layout
        shell: pwsh
        run: |
          $ver = "$env:VERSION"
          $dest = Join-Path $env:VPK_OUT $ver
          if (Test-Path $dest) { Remove-Item $dest -Recurse -Force }
          New-Item $dest -ItemType Directory | Out-Null
          # Mueve todo lo generado por vpk (archivos y carpetas) a la subcarpeta de versión
          Get-ChildItem $env:VPK_OUT -Force | Where-Object { $_.Name -ne $ver } | Move-Item -Destination $dest
          Write-Host "Versioned folder: $dest"
          Get-ChildItem $dest | Format-List FullName

      - name: Generate latest.json (fs/latest.json)
        shell: pwsh
        run: |
            git fetch --tags --force

            $ver  = "$env:VERSION"
            $tag  = "${{ github.ref_name }}"
            # Lee el cuerpo del tag anotado (si es lightweight, quedará vacío)
            $tagMsg = (git for-each-ref "refs/tags/$tag" --format="%(contents)") -join "`n"
            if ([string]::IsNullOrWhiteSpace($tagMsg)) {
                # Fallback: usa el título del tag o un texto por defecto
                $tagMsg = "Auto-release $ver"
            }
            $tagMsg = $tagMsg.Trim()

            $base = "https://pub-ad842211e29b462e97dfbfd5bb04312c.r2.dev/fs/releases/$ver"
            $now  = (Get-Date).ToUniversalTime().ToString("s") + "Z"

            $obj = [ordered]@{
                version     = $ver
                baseUrl     = $base
                publishedAt = $now
                notes       = $tagMsg
            }

            $json = ($obj | ConvertTo-Json -Depth 5)
            $latestPath = Join-Path $env:VPK_OUT "latest.json"
            # En PS7, utf8NoBOM evita BOM
            $json | Set-Content $latestPath -Encoding utf8NoBOM

            Write-Host "latest.json:"
            Get-Content $latestPath

      # No uses configure-aws-credentials (STS) con R2. Exporta claves estáticas sin token.
      - name: Configure AWS env for R2 (no STS)
        shell: pwsh
        run: |
          "AWS_ACCESS_KEY_ID=${{ secrets.R2_ACCESS_KEY_ID }}"         | Out-File -FilePath $env:GITHUB_ENV -Append
          "AWS_SECRET_ACCESS_KEY=${{ secrets.R2_SECRET_ACCESS_KEY }}" | Out-File -FilePath $env:GITHUB_ENV -Append
          "AWS_DEFAULT_REGION=us-east-1"                              | Out-File -FilePath $env:GITHUB_ENV -Append
          "AWS_EC2_METADATA_DISABLED=true"                            | Out-File -FilePath $env:GITHUB_ENV -Append
          "AWS_S3_FORCE_PATH_STYLE=true"                              | Out-File -FilePath $env:GITHUB_ENV -Append
          "AWS_SESSION_TOKEN="                                        | Out-File -FilePath $env:GITHUB_ENV -Append

      - name: Ensure AWS CLI is available (install if missing)
        shell: pwsh
        run: |
          if (-not (Get-Command aws -ErrorAction SilentlyContinue)) {
            choco install awscli -y
          }
          aws --version

      - name: Upload versioned artifacts and latest.json to R2
        shell: pwsh
        env:
          R2_BUCKET: ${{ vars.R2_BUCKET }}                # ej: nuvai
          R2_ENDPOINT_URL: ${{ secrets.R2_ENDPOINT_URL }} # ej: https://<account_id>.r2.cloudflarestorage.com
        run: |
          $ver = "$env:VERSION"
          $verDir = Join-Path $env:VPK_OUT $ver

          # Sube TODOS los artefactos versionados a fs/releases/<VERSION>/
          aws s3 cp "$verDir\" "s3://$env:R2_BUCKET/$env:R2_PREFIX/releases/$ver/" `
            --recursive --endpoint-url "$env:R2_ENDPOINT_URL" --no-progress

          # Sube latest.json a fs/latest.json (sin cache)
          aws s3 cp (Join-Path $env:VPK_OUT "latest.json") "s3://$env:R2_BUCKET/$env:R2_PREFIX/latest.json" `
            --endpoint-url "$env:R2_ENDPOINT_URL" --cache-control "no-cache" --content-type "application/json" --metadata-directive REPLACE

      - name: List VPK output (debug)
        shell: pwsh
        run: |
          Write-Host "VPK_OUT=$env:VPK_OUT"
          Get-ChildItem "$env:VPK_OUT" -Recurse | Format-List FullName

      - name: Create GitHub Release (optional)
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ github.ref_name }}
          name: ${{ github.ref_name }}
          files: |
            ${{ env.VPK_OUT }}/**/*.exe
            ${{ env.VPK_OUT }}/**/*.nupkg
            ${{ env.VPK_OUT }}/**/releases*.json
            ${{ env.VPK_OUT }}/latest.json
          token: ${{ secrets.GITHUB_TOKEN }}
